<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Some-Fun</title>
  
  <subtitle>唯有美食与爱不可辜负</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-30T03:37:37.665Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>粽子大人</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>apply()与call()的区别</title>
    <link href="http://yoursite.com/2018/10/30/apply()%E4%B8%8Ecall()%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/10/30/apply()与call()的区别/</id>
    <published>2018-10-30T02:56:22.000Z</published>
    <updated>2018-10-30T03:37:37.665Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="apply-与call-的区别"><a href="#apply-与call-的区别" class="headerlink" title="apply()与call()的区别"></a>apply()与call()的区别</h2><p>一直都没太明白apply()与call()的具体使用原理，今日闲来无事，决定好好研究一番。</p><p>JavaScript中的每一个Function对象都有一个apply()方法和一个call()方法，它们的语法分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/apply()方法/</span><br><span class="line"></span><br><span class="line">function.apply(thisObj[, argArray])</span><br><span class="line"></span><br><span class="line">/call()方法/</span><br><span class="line"></span><br><span class="line">function.call(thisObj[, arg1[, arg2[, [,...argN]]]]);</span><br></pre></td></tr></table></figure><h3 id="它们各自的定义："><a href="#它们各自的定义：" class="headerlink" title="它们各自的定义："></a>它们各自的定义：</h3><p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。</p><p>call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。</p><h3 id="它们的共同之处："><a href="#它们的共同之处：" class="headerlink" title="它们的共同之处："></a>它们的共同之处：</h3><p>都“可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象”。</p><h3 id="它们的不同之处："><a href="#它们的不同之处：" class="headerlink" title="它们的不同之处："></a>它们的不同之处：</h3><p>apply：最多只能有两个参数——新this对象和一个数组argArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果argArray不是一个有效的数组或arguments对象，那么将导致一个TypeError。如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数。</p><p>call：它可以接受多个参数，第一个参数与apply一样，后面则是一串参数列表。这个方法主要用在js对象各方法相互调用的时候，使当前this实例指针保持一致，或者在特殊情况下需要改变this指针。如果没有提供thisObj参数，那么 Global 对象被用作thisObj。 </p><p>实际上，apply和call的功能是一样的，只是传入的参数列表形式不同。</p><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><p>（1）基本用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function add(a,b)&#123;</span><br><span class="line"></span><br><span class="line">  return a+b;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sub(a,b)&#123;</span><br><span class="line"></span><br><span class="line">  return a-b;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a1 = add.apply(sub,[4,2]);　　//sub调用add的方法</span><br><span class="line"></span><br><span class="line">var a2 = sub.apply(add,[4,2]);</span><br><span class="line"></span><br><span class="line">alert(a1);  //6     </span><br><span class="line"></span><br><span class="line">alert(a2);  //2</span><br><span class="line"></span><br><span class="line">/call的用法/</span><br><span class="line"></span><br><span class="line">var a1 = add.call(sub,4,2);</span><br></pre></td></tr></table></figure><p>（2）实现继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name)&#123;</span><br><span class="line"></span><br><span class="line">  this.name = name;</span><br><span class="line"></span><br><span class="line">  this.showName = function()&#123;</span><br><span class="line"></span><br><span class="line">        alert(this.name);    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Cat(name)&#123;</span><br><span class="line"></span><br><span class="line">  Animal.apply(this,[name]);    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cat = new Cat(&quot;咕咕&quot;);</span><br><span class="line"></span><br><span class="line">cat.showName();</span><br><span class="line"></span><br><span class="line">/call的用法/</span><br><span class="line"></span><br><span class="line">Animal.call(this,name);</span><br></pre></td></tr></table></figure><p> （3）多重继承</p><pre><code>    function Class10(){  this.showSub = function(a,b){    alert(a - b);  }  }function Class11(){  this.showAdd = function(a,b){    alert(a + b);}}function Class12(){  Class10.apply(this);  Class11.apply(this);     // Class10.call(this);  //Class11.call(this);  }var c2 = new Class12();c2.showSub(3,1);    //2c2.showAdd(3,1);    //4</code></pre><h3 id="apply的一些其他巧妙用法"><a href="#apply的一些其他巧妙用法" class="headerlink" title="apply的一些其他巧妙用法"></a>apply的一些其他巧妙用法</h3><p>（1）Math.max 可以实现得到数组中最大的一项：</p><p>因为Math.max不支持Math.max([param1,param2])也就是数组，但是它支持Math.max(param1,param2…)，所以可以根据apply的特点来解决 var max=Math.max.apply(null,array)，这样就轻易的可以得到一个数组中的最大项（apply会将一个数组转换为一个参数接一个参</p><p>数的方式传递给方法）</p><p>这块在调用的时候第一个参数给了null，这是因为没有对象去调用这个方法，我只需要用这个方法帮我运算，得到返回的结果就行，所以直接传递了一个null过去。</p><p>用这种方法也可以实现得到数组中的最小项：Math.min.apply(null,array)</p><p>（2）Array.prototype.push可以实现两个数组的合并</p><p>同样push方法没有提供push一个数组，但是它提供了push(param1,param2…paramN)，同样也可以用apply来转换一下这个数组，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr1=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);</span><br><span class="line"></span><br><span class="line">var arr2=new Array(&quot;4&quot;,&quot;5&quot;,&quot;6&quot;);</span><br><span class="line"></span><br><span class="line">Array.prototype.push.apply(arr1,arr2);    //得到合并后数组的长度，因为push就是返回一个数组的长度</span><br></pre></td></tr></table></figure><p>也可以这样理解，arr1调用了push方法，参数是通过apply将数组转换为参数列表的集合</p><p>通常在什么情况下，可以使用apply类似Math.max等之类的特殊用法：</p><p>一般在目标函数只需要n个参数列表，而不接收一个数组的形式，可以通过apply的方式巧妙地解决这个问题。</p><p><img src="/2018/10/30/apply()与call()的区别/apply与call.png" alt="ac"></p><p><a href="https://www.cnblogs.com/lengyuehuahun/p/5643625.html" target="_blank" rel="noopener">本文转载自：</a> <a href="https://www.cnblogs.com/lengyuehuahun/p/5643625.html" target="_blank" rel="noopener">https://www.cnblogs.com/lengyuehuahun/p/5643625.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;apply-与call-的区别&quot;&gt;&lt;a href=&quot;#apply-与call-的区别&quot; class=&quot;headerlink&quot; title=&quot;apply()与call
      
    
    </summary>
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>箭头函数与普通函数的区别</title>
    <link href="http://yoursite.com/2018/10/30/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/10/30/箭头函数与普通函数的区别/</id>
    <published>2018-10-30T00:35:14.000Z</published>
    <updated>2018-10-30T02:21:29.834Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>箭头函数：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let fun = () =&gt; &#123;</span><br><span class="line">  console.log(&apos;balabala&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通函数：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fun() &#123;</span><br><span class="line">console.log(&apos;balabalabalala&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头函数相当于匿名函数，并简化了函数定义。箭头函数有两种格式，一种只包含一个表达式，连{…} 和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略了。  </p><h2 id="箭头函数是匿名函数，不能作为构造函数，不能使用new"><a href="#箭头函数是匿名函数，不能作为构造函数，不能使用new" class="headerlink" title="箭头函数是匿名函数，不能作为构造函数，不能使用new"></a>箭头函数是匿名函数，不能作为构造函数，不能使用new</h2><figure class="highlight plain"><figcaption><span>FunConstructor </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let FunConstructor = () =&gt; &#123;</span><br><span class="line">console.log(&apos;hahaha&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let fc = new FunConstructor();</span><br></pre></td></tr></table></figure><p><img src="/2018/10/30/箭头函数与普通函数的区别/jt.png" alt="jt">  </p><h2 id="箭头函数不绑定arguments，取而代之用rest参数…解决"><a href="#箭头函数不绑定arguments，取而代之用rest参数…解决" class="headerlink" title="箭头函数不绑定arguments，取而代之用rest参数…解决"></a>箭头函数不绑定arguments，取而代之用rest参数…解决</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function A(a) &#123;</span><br><span class="line">  console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">A(1,2,3,4,5,6);// [1 ,2, 3, 4, 5, 6, callee: f,Symbol(Symbol.iterator): f]</span><br><span class="line"></span><br><span class="line">let B= (b) =&gt; &#123;</span><br><span class="line">console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">B(1,2,3,4); // Uncaught ReferenceError: arguments is not defined</span><br><span class="line"></span><br><span class="line">let C = (...c) =&gt; &#123;</span><br><span class="line">  console.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C(1,2,3,4); // [1,2,3,4]</span><br></pre></td></tr></table></figure><h2 id="箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值"><a href="#箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值" class="headerlink" title="箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值"></a>箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值</h2><h3 id="普通函数中的this："><a href="#普通函数中的this：" class="headerlink" title="普通函数中的this："></a>普通函数中的this：</h3><p>1.this总是代表他的直接调用者，例如 obj.func, 那么func中的this就是obj</p><p>2.在默认情况（非严格模式下，未使用‘use stric’），没找到直接调用者，则this值得是window</p><p>3.在严格模式下，没有直接调用者的函数中的this是undefined</p><p>4.使用call，apply，bind绑定的，this指的是绑定的对象</p><h3 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h3><p>默认指向在定义它时，它所处的对象，而不是执行时的对象，定义它时，可能环境是window（即继承父级的this）；  </p><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  say: function () &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(this)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say();</span><br></pre></td></tr></table></figure><p>结果是：window  </p><p>匿名函数，定时器中的函数，由于没有默认的宿主对象，所以默认this指向window  </p><p>用一个 变量提前把正确的 this引用保存 起来, 我们通常使用that = this, 或者 _this = this来保存我们需要的this指针!  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    func: function() &#123;&#125;,</span><br><span class="line">    say: function () &#123;</span><br><span class="line">      var that = this;   //此时的this就是obj对象</span><br><span class="line">      setTimeout(function () &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">        that.func()</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.say();</span><br></pre></td></tr></table></figure><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">window.val = 1;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  val: 2,</span><br><span class="line">  dbl: function () &#123;</span><br><span class="line">    this.val *= 2;</span><br><span class="line">    val *= 2;</span><br><span class="line">    console.log(val);</span><br><span class="line">    console.log(this.val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 说出下面的输出结果</span><br><span class="line">obj.dbl();</span><br><span class="line">var func = obj.dbl;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>结果是：2  4  8  8</p><p><1> 12行代码调用</1></p><p>val变量在没有指定对象前缀,默认从函数中找,找不到则从window中找全局变量</p><p>即 val <em>=2 就是 window.val </em>= 2</p><p>this.val默认指的是 obj.val ;因为 dbl()第一次被obj直接调用</p><p><2>14行代码调用</2></p><p>func() 没有任何前缀,类似于全局函数,即  window.func调用,所以</p><p>第二次调用的时候, this指的是window, val指的是window.val</p><p>第二次的结果受第一次的影响  </p><h4 id="示例3-在严格模式下的this"><a href="#示例3-在严格模式下的this" class="headerlink" title="示例3.在严格模式下的this"></a>示例3.在严格模式下的this</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">   &apos;use strict&apos;;</span><br><span class="line">   console.log(this);</span><br><span class="line"> &#125;</span><br><span class="line"> test();</span><br></pre></td></tr></table></figure><p>结果是：undefined  </p><h4 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    say: function () &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.say(); // obj</span><br></pre></td></tr></table></figure><p>此时的this是定义它的对象，即继承父级的this,父级中的this指的是obj,而非window  </p><h4 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">   say: function () &#123;</span><br><span class="line">     var f1 = () =&gt; &#123;</span><br><span class="line">       console.log(this); // obj</span><br><span class="line">       setTimeout(() =&gt; &#123;</span><br><span class="line">         console.log(this); // obj</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">     f1();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> obj.say()</span><br></pre></td></tr></table></figure><p>结果：都是obj</p><p>f1继承父级this指代的obj，不管f1有多层箭头函数嵌套，都是obj.</p><h4 id="示例6"><a href="#示例6" class="headerlink" title="示例6"></a>示例6</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    say: function () &#123;</span><br><span class="line">      var f1 = function () &#123;</span><br><span class="line">        console.log(this);    // window, f1调用时,没有宿主对象,默认是window</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(this); // window</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;;</span><br><span class="line">      f1();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.say()</span><br></pre></td></tr></table></figure><p>结果：window,window</p><p>第一个this：f1调用时没有宿主对象，默认是window</p><p>第二个this:继承父级的this,父级的this指代的是window.</p><h2 id="箭头函数通过-call-或-apply-方法调用一个函数时，只传入了一个参数，对-this-并没有影响。"><a href="#箭头函数通过-call-或-apply-方法调用一个函数时，只传入了一个参数，对-this-并没有影响。" class="headerlink" title="箭头函数通过 call()  或   apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。"></a>箭头函数通过 call()  或   apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let obj2 = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    b: function(n) &#123;</span><br><span class="line">        let f = (n) =&gt; n + this.a;</span><br><span class="line">        return f(n);</span><br><span class="line">    &#125;,</span><br><span class="line">    c: function(n) &#123;</span><br><span class="line">        let f = (n) =&gt; n + this.a;</span><br><span class="line">        let m = &#123;</span><br><span class="line">            a: 20</span><br><span class="line">        &#125;;</span><br><span class="line">        return f.call(m,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj2.b(1));  // 11</span><br><span class="line">console.log(obj2.c(1)); // 11</span><br></pre></td></tr></table></figure><h2 id="箭头函数没有原型属性"><a href="#箭头函数没有原型属性" class="headerlink" title="箭头函数没有原型属性"></a>箭头函数没有原型属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = ()=&gt;&#123;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b()&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(a.prototype);  // undefined</span><br><span class="line">console.log(b.prototype);   // &#123;constructor: ƒ&#125;</span><br></pre></td></tr></table></figure><h2 id="箭头函数不能当做Generator函数-不能使用yield关键字"><a href="#箭头函数不能当做Generator函数-不能使用yield关键字" class="headerlink" title="箭头函数不能当做Generator函数,不能使用yield关键字"></a>箭头函数不能当做Generator函数,不能使用yield关键字</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>箭头函数的 this 永远指向其上下文的  this ，任何方法都改变不了其指向，如 call() ,  bind() ,  apply()   </li><li>普通函数的this指向调用它的那个对象  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;箭头函数：  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端ES6新特性</title>
    <link href="http://yoursite.com/2018/10/28/es6/"/>
    <id>http://yoursite.com/2018/10/28/es6/</id>
    <published>2018-10-28T13:48:46.000Z</published>
    <updated>2018-10-29T09:56:50.038Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><h3 id="解构对象"><a href="#解构对象" class="headerlink" title="解构对象"></a>解构对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;小黑&apos;,</span><br><span class="line">    age: &apos;10&apos;</span><br><span class="line">&#125;</span><br><span class="line">var &#123;name , age&#125; = obj;</span><br><span class="line">console.log(name,age);//&apos;小黑&apos;  10</span><br></pre></td></tr></table></figure><h3 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4];  </span><br><span class="line">var [a,b,c,d] = arr;  </span><br><span class="line"></span><br><span class="line">console.log(a,b,c,d);//a = 1, b = 2, c = 3, d = 4;</span><br></pre></td></tr></table></figure><h4 id="解构数组-结合-拓展运算符"><a href="#解构数组-结合-拓展运算符" class="headerlink" title="解构数组 结合 拓展运算符"></a>解构数组 结合 拓展运算符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4];  </span><br><span class="line">var [a,...d] = arr;</span><br><span class="line">console.log(d);//2,3,4</span><br></pre></td></tr></table></figure><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><ol><li>let<br>定义一个作用域被限制在块级中的变量、语句或者表达式</li><li>const<br>定义常量<br>ps: 都没有变量提升，都具有 {} 作用域，const定义的值不能，重新赋值，并一定在定义的时候赋值   </li></ol><h3 id="字符串的拓展"><a href="#字符串的拓展" class="headerlink" title="字符串的拓展"></a>字符串的拓展</h3><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>使用${}给变量站位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = 111;  </span><br><span class="line">var str2 = 222;</span><br><span class="line">`$&#123;str&#125;-------$&#123;str2&#125;` //111-------222</span><br></pre></td></tr></table></figure></p><h4 id="startsWith、endsWith"><a href="#startsWith、endsWith" class="headerlink" title="startsWith、endsWith"></a>startsWith、endsWith</h4><p>判断字符串开头或者结尾是否存在某个字符串 ，返回true 或者false  </p><h4 id="padStart、padEnd-字符串拼接"><a href="#padStart、padEnd-字符串拼接" class="headerlink" title="padStart、padEnd 字符串拼接"></a>padStart、padEnd 字符串拼接</h4><ol><li><p>padStart(length,str) length 是拼接后的字符串的总长度，str是要使用什么字符串拼接  （开头）   </p></li><li><p>EndStart(length,str) length 是拼接后的字符串的总长度，str是要使用什么字符串拼接  （末尾）  </p></li></ol><h3 id="rest参数和-拓展运算符"><a href="#rest参数和-拓展运算符" class="headerlink" title="rest参数和 拓展运算符"></a>rest参数和 拓展运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function show(...rest) &#123;</span><br><span class="line">    //在函数定义使用的...obj叫rest参数</span><br><span class="line">    //使用...rest 那么rest 类型为数组</span><br><span class="line">    var result = 0;</span><br><span class="line">    rest.forEach(item =&gt; &#123;</span><br><span class="line">        result += item;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 参数不确定</span><br><span class="line">// show(1,2,3,4);</span><br><span class="line">var arr = [1,2,3,4];</span><br><span class="line">show(...arr) //在函数调用时使用的...obj饺子拓展运算符</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;解构&quot;&gt;&lt;a href=&quot;#解构&quot; class=&quot;headerlink&quot; title=&quot;解构&quot;&gt;&lt;/a&gt;解构&lt;/h2&gt;&lt;h3 id=&quot;解构对象&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="fontend" scheme="http://yoursite.com/tags/fontend/"/>
    
  </entry>
  
  <entry>
    <title>韩国柚子茶食谱-百香果柚子苏打水</title>
    <link href="http://yoursite.com/2018/10/28/page/"/>
    <id>http://yoursite.com/2018/10/28/page/</id>
    <published>2018-10-28T11:01:57.000Z</published>
    <updated>2018-10-28T12:32:00.710Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p> &emsp;有一次看微博说百香果和柠檬放到苏打水里很好喝，就试了试，没想到真的挺不错。因为我本来是不太喜欢喝苏打水，觉得过于寡淡。这次另外加入了蜂蜜柚子茶，口感更丰富，很惊喜的味道。做法也简单得不行，一起试试吧～   </p><h2 id="用料"><a href="#用料" class="headerlink" title="用料  "></a><font color="rgb(192, 174, 125)">用料  </font></h2><p> 百香果&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;   1个<br>柠檬&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;  3片<br>苏打水&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;    一罐<br>贴有韩国柚子茶品质标示的柚子茶&emsp;两勺<br><br></p><h2 id="韩国柚子茶食谱-百香果柚子苏打水的做法"><a href="#韩国柚子茶食谱-百香果柚子苏打水的做法" class="headerlink" title=" 韩国柚子茶食谱-百香果柚子苏打水的做法  "></a><font color="rgb(192, 174, 125)"> 韩国柚子茶食谱-百香果柚子苏打水的做法  </font></h2><h3 id="1-emsp-准备好材料，这次用的柠檬是上次做的蜜泽青柠。也可以用新鲜柠檬切片。材料也不拘泥于这几种，可按自己喜好。"><a href="#1-emsp-准备好材料，这次用的柠檬是上次做的蜜泽青柠。也可以用新鲜柠檬切片。材料也不拘泥于这几种，可按自己喜好。" class="headerlink" title="1 &emsp; 准备好材料，这次用的柠檬是上次做的蜜泽青柠。也可以用新鲜柠檬切片。材料也不拘泥于这几种，可按自己喜好。"></a><font color="rgb(192, 174, 125)">1</font> &emsp; 准备好材料，这次用的柠檬是上次做的蜜泽青柠。也可以用新鲜柠檬切片。材料也不拘泥于这几种，可按自己喜好。<img src="/2018/10/28/page/truefirst.jpg" alt="“图片描述”"></h3><h3 id="2-emsp-选用的柚子茶，十分浓郁。是经过韩国柚子茶品质认证的。"><a href="#2-emsp-选用的柚子茶，十分浓郁。是经过韩国柚子茶品质认证的。" class="headerlink" title="2  &emsp; 选用的柚子茶，十分浓郁。是经过韩国柚子茶品质认证的。 "></a><font color="rgb(192, 174, 125)">2</font>  &emsp; 选用的柚子茶，十分浓郁。是经过韩国柚子茶品质认证的。 <img src="/2018/10/28/page/truesecond.jpg" alt="“图片描述”"></h3><h3 id="3-emsp-放入三片柠檬，两勺柚子茶，一个百香果的果汁。最后倒入一罐苏打水。"><a href="#3-emsp-放入三片柠檬，两勺柚子茶，一个百香果的果汁。最后倒入一罐苏打水。" class="headerlink" title="3 &emsp; 放入三片柠檬，两勺柚子茶，一个百香果的果汁。最后倒入一罐苏打水。"></a><font color="rgb(192, 174, 125)">3</font> &emsp; 放入三片柠檬，两勺柚子茶，一个百香果的果汁。最后倒入一罐苏打水。<img src="/2018/10/28/page/firststep.jpg" alt="“图片描述”"></h3><h3 id="5-emsp-搅匀就可以喝啦。"><a href="#5-emsp-搅匀就可以喝啦。" class="headerlink" title="5 &emsp;搅匀就可以喝啦。"></a><font color="rgb(192, 174, 125)">5</font> &emsp;搅匀就可以喝啦。<img src="/2018/10/28/page/secondstep.jpg" alt="“图片描述”"></h3><h3 id="6-emsp-也可以添加适量冰块。别问我为啥还在喝这么夏天的饮料，因为10月下旬了广州还是30度。"><a href="#6-emsp-也可以添加适量冰块。别问我为啥还在喝这么夏天的饮料，因为10月下旬了广州还是30度。" class="headerlink" title="6 &emsp;也可以添加适量冰块。别问我为啥还在喝这么夏天的饮料，因为10月下旬了广州还是30度。"></a><font color="rgb(192, 174, 125)">6</font> &emsp;也可以添加适量冰块。别问我为啥还在喝这么夏天的饮料，因为10月下旬了广州还是30度。<img src="/2018/10/28/page/thirdstep.jpg" alt="“图片描述”"></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt; &amp;emsp;有一次看微博说百香果和柠檬放到苏打水里很好喝，就试了试，没想到真的挺不错。因为我本来是不太喜欢喝苏打水，觉得过于寡淡。这次另外加入了蜂蜜柚子茶，口感更丰富，很惊
      
    
    </summary>
    
    
      <category term="food" scheme="http://yoursite.com/tags/food/"/>
    
  </entry>
  
  <entry>
    <title>第一篇文章</title>
    <link href="http://yoursite.com/2018/10/27/hello-world/"/>
    <id>http://yoursite.com/2018/10/27/hello-world/</id>
    <published>2018-10-27T06:21:32.057Z</published>
    <updated>2018-10-27T13:04:37.757Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>歌手:林志炫</p><p><strong>*</strong>离人<strong>*</strong><br>林志炫<br>词: 厉曼婷 曲: 何家文</p><p>银色小船摇摇晃晃弯弯<br>悬在绒绒的天上<br>你的心事三三俩俩蓝蓝<br>停在我幽幽心上<br>你说情到深处人怎能不孤独<br>爱到浓时就牵肠挂肚<br>我的行李孤孤单单散散惹惆怅<br>离人放逐到边界<br>彷佛走入第五个季节<br>昼夜乱了和谐 潮泛任性涨退<br>字典里没春天<br>离人挥霍著眼泪<br>回避还在眼前的离别<br>你不敢想明天<br>我不肯说再见<br>有人说一次告别<br>天上就会有颗星又熄灭<br>(music)<br>银色小船摇摇晃晃弯弯<br>悬在绒绒的天上<br>你的心事三三俩俩蓝蓝<br>停在我幽幽心上<br>你说情到深处人怎能不孤独<br>爱到浓时就牵肠挂肚<br>我的行李孤孤单单散散惹惆怅<br>离人放逐到边界<br>彷佛走入第五个季节<br>昼夜乱了和谐 潮泛任性涨退<br>字典里没春天<br>离人挥霍著眼泪<br>回避还在眼前的离别<br>你不敢想明天<br>我不肯说再见<br>有人说一次告别<br>天上就会有颗星又熄灭</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;歌手:林志炫&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;*&lt;/strong&gt;离人&lt;strong&gt;*&lt;/strong&gt;&lt;br&gt;林志炫&lt;br&gt;词: 厉曼婷 曲: 何家文&lt;/p&gt;
&lt;p&gt;银色小
      
    
    </summary>
    
    
  </entry>
  
</feed>
