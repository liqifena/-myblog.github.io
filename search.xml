<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[apply与call（）的区别]]></title>
    <url>%2F2018%2F10%2F30%2Fapply%E4%B8%8Ecall%EF%BC%88%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[apply()与call()的区别一直都没太明白apply()与call()的具体使用原理，今日闲来无事，决定好好研究一番。 JavaScript中的每一个Function对象都有一个apply()方法和一个call()方法，它们的语法分别为： 1234567/apply()方法/function.apply(thisObj[, argArray])/call()方法/function.call(thisObj[, arg1[, arg2[, [,...argN]]]]); 它们各自的定义：apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。 call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。 它们的共同之处：都“可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象”。 它们的不同之处：apply：最多只能有两个参数——新this对象和一个数组argArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果argArray不是一个有效的数组或arguments对象，那么将导致一个TypeError。如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数。 call：它可以接受多个参数，第一个参数与apply一样，后面则是一串参数列表。这个方法主要用在js对象各方法相互调用的时候，使当前this实例指针保持一致，或者在特殊情况下需要改变this指针。如果没有提供thisObj参数，那么 Global 对象被用作thisObj。 实际上，apply和call的功能是一样的，只是传入的参数列表形式不同。 示例代码：（1）基本用法 1234567891011121314151617181920212223function add(a,b)&#123; return a+b; &#125;function sub(a,b)&#123; return a-b; &#125;var a1 = add.apply(sub,[4,2]); //sub调用add的方法var a2 = sub.apply(add,[4,2]);alert(a1); //6 alert(a2); //2/call的用法/var a1 = add.call(sub,4,2); （2）实现继承 123456789101112131415161718192021222324function Animal(name)&#123; this.name = name; this.showName = function()&#123; alert(this.name); &#125; &#125;function Cat(name)&#123; Animal.apply(this,[name]); &#125;var cat = new Cat(&quot;咕咕&quot;);cat.showName();/call的用法/Animal.call(this,name); （3）多重继承 function Class10(){ this.showSub = function(a,b){ alert(a - b); } } function Class11(){ this.showAdd = function(a,b){ alert(a + b); } } function Class12(){ Class10.apply(this); Class11.apply(this); // Class10.call(this); //Class11.call(this); } var c2 = new Class12(); c2.showSub(3,1); //2 c2.showAdd(3,1); //4 apply的一些其他巧妙用法（1）Math.max 可以实现得到数组中最大的一项： 因为Math.max不支持Math.max([param1,param2])也就是数组，但是它支持Math.max(param1,param2…)，所以可以根据apply的特点来解决 var max=Math.max.apply(null,array)，这样就轻易的可以得到一个数组中的最大项（apply会将一个数组转换为一个参数接一个参 数的方式传递给方法） 这块在调用的时候第一个参数给了null，这是因为没有对象去调用这个方法，我只需要用这个方法帮我运算，得到返回的结果就行，所以直接传递了一个null过去。 用这种方法也可以实现得到数组中的最小项：Math.min.apply(null,array) （2）Array.prototype.push可以实现两个数组的合并 同样push方法没有提供push一个数组，但是它提供了push(param1,param2…paramN)，同样也可以用apply来转换一下这个数组，即： 12345var arr1=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);var arr2=new Array(&quot;4&quot;,&quot;5&quot;,&quot;6&quot;);Array.prototype.push.apply(arr1,arr2); //得到合并后数组的长度，因为push就是返回一个数组的长度 也可以这样理解，arr1调用了push方法，参数是通过apply将数组转换为参数列表的集合 通常在什么情况下，可以使用apply类似Math.max等之类的特殊用法： 一般在目标函数只需要n个参数列表，而不接收一个数组的形式，可以通过apply的方式巧妙地解决这个问题。 本文转载自： https://www.cnblogs.com/lengyuehuahun/p/5643625.html]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[箭头函数与普通函数的区别]]></title>
    <url>%2F2018%2F10%2F30%2F%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[箭头函数： 123let fun = () =&gt; &#123; console.log(&apos;balabala&apos;);&#125; 普通函数： 123function fun() &#123; console.log(&apos;balabalabalala&apos;);&#125; 箭头函数相当于匿名函数，并简化了函数定义。箭头函数有两种格式，一种只包含一个表达式，连{…} 和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略了。 箭头函数是匿名函数，不能作为构造函数，不能使用newFunConstructor 12345let FunConstructor = () =&gt; &#123; console.log(&apos;hahaha&apos;);&#125;let fc = new FunConstructor(); 箭头函数不绑定arguments，取而代之用rest参数…解决123456789101112131415function A(a) &#123; console.log(arguments);&#125;A(1,2,3,4,5,6);// [1 ,2, 3, 4, 5, 6, callee: f,Symbol(Symbol.iterator): f]let B= (b) =&gt; &#123; console.log(arguments);&#125;B(1,2,3,4); // Uncaught ReferenceError: arguments is not definedlet C = (...c) =&gt; &#123; console.log(c);&#125;C(1,2,3,4); // [1,2,3,4] 箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值普通函数中的this：1.this总是代表他的直接调用者，例如 obj.func, 那么func中的this就是obj 2.在默认情况（非严格模式下，未使用‘use stric’），没找到直接调用者，则this值得是window 3.在严格模式下，没有直接调用者的函数中的this是undefined 4.使用call，apply，bind绑定的，this指的是绑定的对象 箭头函数中的this默认指向在定义它时，它所处的对象，而不是执行时的对象，定义它时，可能环境是window（即继承父级的this）； 示例112345678var obj = &#123; say: function () &#123; setTimeout(function () &#123; console.log(this) &#125;); &#125;&#125;obj.say(); 结果是：window 匿名函数，定时器中的函数，由于没有默认的宿主对象，所以默认this指向window 用一个 变量提前把正确的 this引用保存 起来, 我们通常使用that = this, 或者 _this = this来保存我们需要的this指针! 1234567891011var obj = &#123; func: function() &#123;&#125;, say: function () &#123; var that = this; //此时的this就是obj对象 setTimeout(function () &#123; console.log(this) that.func() &#125;); &#125; &#125; obj.say(); 示例21234567891011121314window.val = 1;var obj = &#123; val: 2, dbl: function () &#123; this.val *= 2; val *= 2; console.log(val); console.log(this.val); &#125;&#125;;// 说出下面的输出结果obj.dbl();var func = obj.dbl;func(); 结果是：2 4 8 8 12行代码调用 val变量在没有指定对象前缀,默认从函数中找,找不到则从window中找全局变量 即 val =2 就是 window.val = 2 this.val默认指的是 obj.val ;因为 dbl()第一次被obj直接调用 14行代码调用 func() 没有任何前缀,类似于全局函数,即 window.func调用,所以 第二次调用的时候, this指的是window, val指的是window.val 第二次的结果受第一次的影响 示例3.在严格模式下的this12345function test() &#123; &apos;use strict&apos;; console.log(this); &#125; test(); 结果是：undefined 示例412345678var obj = &#123; say: function () &#123; setTimeout(() =&gt; &#123; console.log(this) &#125;); &#125; &#125; obj.say(); // obj 此时的this是定义它的对象，即继承父级的this,父级中的this指的是obj,而非window 示例5123456789101112var obj = &#123; say: function () &#123; var f1 = () =&gt; &#123; console.log(this); // obj setTimeout(() =&gt; &#123; console.log(this); // obj &#125;) &#125; f1(); &#125; &#125; obj.say() 结果：都是obj f1继承父级this指代的obj，不管f1有多层箭头函数嵌套，都是obj. 示例6123456789101112var obj = &#123; say: function () &#123; var f1 = function () &#123; console.log(this); // window, f1调用时,没有宿主对象,默认是window setTimeout(() =&gt; &#123; console.log(this); // window &#125;) &#125;; f1(); &#125; &#125; obj.say() 结果：window,window 第一个this：f1调用时没有宿主对象，默认是window 第二个this:继承父级的this,父级的this指代的是window. 箭头函数通过 call() 或 apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。12345678910111213141516let obj2 = &#123; a: 10, b: function(n) &#123; let f = (n) =&gt; n + this.a; return f(n); &#125;, c: function(n) &#123; let f = (n) =&gt; n + this.a; let m = &#123; a: 20 &#125;; return f.call(m,n); &#125;&#125;;console.log(obj2.b(1)); // 11console.log(obj2.c(1)); // 11 箭头函数没有原型属性12345678910var a = ()=&gt;&#123; return 1;&#125;function b()&#123; return 2;&#125;console.log(a.prototype); // undefinedconsole.log(b.prototype); // &#123;constructor: ƒ&#125; 箭头函数不能当做Generator函数,不能使用yield关键字总结 箭头函数的 this 永远指向其上下文的 this ，任何方法都改变不了其指向，如 call() , bind() , apply() 普通函数的this指向调用它的那个对象]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端ES6新特性]]></title>
    <url>%2F2018%2F10%2F28%2Fes6%2F</url>
    <content type="text"><![CDATA[解构解构对象123456var obj = &#123; name: &apos;小黑&apos;, age: &apos;10&apos;&#125;var &#123;name , age&#125; = obj;console.log(name,age);//&apos;小黑&apos; 10 解构数组1234var arr = [1,2,3,4]; var [a,b,c,d] = arr; console.log(a,b,c,d);//a = 1, b = 2, c = 3, d = 4; 解构数组 结合 拓展运算符123var arr = [1,2,3,4]; var [a,...d] = arr;console.log(d);//2,3,4 定义变量 let定义一个作用域被限制在块级中的变量、语句或者表达式 const定义常量ps: 都没有变量提升，都具有 {} 作用域，const定义的值不能，重新赋值，并一定在定义的时候赋值 字符串的拓展模板字符串使用${}给变量站位123var str = 111; var str2 = 222;`$&#123;str&#125;-------$&#123;str2&#125;` //111-------222 startsWith、endsWith判断字符串开头或者结尾是否存在某个字符串 ，返回true 或者false padStart、padEnd 字符串拼接 padStart(length,str) length 是拼接后的字符串的总长度，str是要使用什么字符串拼接 （开头） EndStart(length,str) length 是拼接后的字符串的总长度，str是要使用什么字符串拼接 （末尾） rest参数和 拓展运算符123456789101112131415function show(...rest) &#123; //在函数定义使用的...obj叫rest参数 //使用...rest 那么rest 类型为数组 var result = 0; rest.forEach(item =&gt; &#123; result += item; &#125;); console.log(result);&#125;// 参数不确定// show(1,2,3,4);var arr = [1,2,3,4];show(...arr) //在函数调用时使用的...obj饺子拓展运算符]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>fontend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[韩国柚子茶食谱-百香果柚子苏打水]]></title>
    <url>%2F2018%2F10%2F28%2Fpage%2F</url>
    <content type="text"><![CDATA[&emsp;有一次看微博说百香果和柠檬放到苏打水里很好喝，就试了试，没想到真的挺不错。因为我本来是不太喜欢喝苏打水，觉得过于寡淡。这次另外加入了蜂蜜柚子茶，口感更丰富，很惊喜的味道。做法也简单得不行，一起试试吧～ 用料 百香果&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 1个柠檬&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 3片苏打水&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 一罐贴有韩国柚子茶品质标示的柚子茶&emsp;两勺 韩国柚子茶食谱-百香果柚子苏打水的做法 1 &emsp; 准备好材料，这次用的柠檬是上次做的蜜泽青柠。也可以用新鲜柠檬切片。材料也不拘泥于这几种，可按自己喜好。2 &emsp; 选用的柚子茶，十分浓郁。是经过韩国柚子茶品质认证的。 3 &emsp; 放入三片柠檬，两勺柚子茶，一个百香果的果汁。最后倒入一罐苏打水。5 &emsp;搅匀就可以喝啦。6 &emsp;也可以添加适量冰块。别问我为啥还在喝这么夏天的饮料，因为10月下旬了广州还是30度。]]></content>
      <tags>
        <tag>food</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <url>%2F2018%2F10%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[歌手:林志炫 *离人*林志炫词: 厉曼婷 曲: 何家文 银色小船摇摇晃晃弯弯悬在绒绒的天上你的心事三三俩俩蓝蓝停在我幽幽心上你说情到深处人怎能不孤独爱到浓时就牵肠挂肚我的行李孤孤单单散散惹惆怅离人放逐到边界彷佛走入第五个季节昼夜乱了和谐 潮泛任性涨退字典里没春天离人挥霍著眼泪回避还在眼前的离别你不敢想明天我不肯说再见有人说一次告别天上就会有颗星又熄灭(music)银色小船摇摇晃晃弯弯悬在绒绒的天上你的心事三三俩俩蓝蓝停在我幽幽心上你说情到深处人怎能不孤独爱到浓时就牵肠挂肚我的行李孤孤单单散散惹惆怅离人放逐到边界彷佛走入第五个季节昼夜乱了和谐 潮泛任性涨退字典里没春天离人挥霍著眼泪回避还在眼前的离别你不敢想明天我不肯说再见有人说一次告别天上就会有颗星又熄灭]]></content>
  </entry>
</search>
